#!/usr/bin/env python
"""This script parses scores from a range of solution files generated by problem solvers.
It extracts scores from text files named `solutionX.txt` in a specified directory and prints them.

Usage:
    python3 parse_score.py <n> <solver>
    
Arguments:
    <n> (int): The problem set size, which determines the directory structure.
    <solver> (str): The problem solver whose results you want to parse.

Directory Structure:
    ../../data/n<n>/solutions/<solver>/solutionX.txt
    where <n> is the problem size and <solver> is the solver type.

Example:
    python3 parse_score.py 8 backtrack
    This will parse scores from files in ../../data/n8/solutions/backtrack/
"""

import os
import sys

__author__ = "Murhaf Alawir, Anas Alatasi"
__copyright__ = "Global1A1"
__credits__ = ["Murhaf Alawir", "Anas Alatasi"]
__license__ = "Apache 2.0"
__version__ = "1.0.0"
__maintainer__ = "Murhaf Alawir"
__email__ = "m.alawir@innopolis.university"
__status__ = "Staging"

def parse_score_from_file(filename):
    """Parses a score from a given file.

    The function looks for lines starting with "Score:" or "Second best score:" and extracts the score value.
    It returns the extracted score as a float.

    Args:
        filename (str): The path to the file from which to extract the score.

    Returns:
        float: The extracted score, or None if no score is found in the file.
    """
    score = None
    try:
        with open(filename, 'r') as file:
            for line in file:
                if line.startswith("Score:") or line.startswith("Second best score:"):
                    score = float(line.split(":")[1].strip())
                    break
    except IOError as e:
        print(f"Error reading file {filename}: {e}")
    except ValueError:
        print(f"Error parsing score in file {filename}")
    return score

def parse_scores_from_files(directory, start=1, end=10):
    """Parses scores from a range of files within a specified directory.

    This function generates filenames based on a range (e.g., solution1.txt, solution2.txt, etc.) and extracts
    scores from each file. It collects scores from existing files and returns them in a list.

    Args:
        directory (str): The directory containing the solution files.
        start (int): The starting index of the solution files.
        end (int): The ending index of the solution files.

    Returns:
        list: A list of scores parsed from the files. If a file does not exist or contains no valid score,
              a message is printed, and those scores are omitted.
    """
    scores = []
    for i in range(start, end + 1):
        filename = os.path.join(directory, f"solution{i}.txt")
        if os.path.exists(filename):
            score = parse_score_from_file(filename)
            if score is not None:
                scores.append(score)
            else:
                print(f"No score found in {filename}")
        else:
            print(f"{filename} does not exist")
    return scores

# Main execution
if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("\nUsage: python3 parse_score.py <n> <solver>")
        print("  <n>: The problem set size.")
        print("  <solver>: The problem solver to parse.")
        print("This script expects the following directory structure:")
        print("     ../../data/n<n>/solutions/<solver>/solutionX.txt")
        print("\nExample:")
        print("python3 parse_score.py 8 backtrack")
        print("This will parse scores in ../../data/n8/solutions/backtrack/")
        sys.exit(1)
    
    try:
        n = int(sys.argv[1])
    except ValueError:
        print("Error: <n> must be an integer")
        sys.exit(1)
    
    directory = f"../../data/n{n}/solutions/{sys.argv[2]}"
    
    start_file = 1
    end_file = 8
    
    # Ensure the directory exists
    if os.path.isdir(directory):
        scores = parse_scores_from_files(directory, start=start_file, end=end_file)
        print(scores)
    else:
        print(f"The directory {directory} does not exist.")
